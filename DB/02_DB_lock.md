# 1. DB Lock 이란?

DB Lock은 여러 트랜잭션이 동시에 같은 데이터에 접근할 때

**데이터의 정합성(Consistency)과 무결성(Integrity)을 보장하기 위해,**

**특정 데이터에 대해 읽기 또는 쓰기 권한을 잠시 점유하는 메커니즘**이다.

트랜잭션이 이 데이터는 지금 내가 처리 중이니,

다른 트랜잭션은 건드리지 마라 하고 표시하는 과정이라고 볼 수 있다.

---

# 2. Lock 이 필요한 이유

### 2-1. 동시성 제어(Concurrency Control)

여러 사용자가 동시에 같은 데이터에 접근할 때 값이 뒤섞이거나 잘못 업데이트되는 문제를 방지한다.

ex) A와 B가 동시에 같은 재고를 감소시키면 재고가 음수로 내려가는 문제 같은 것.

### 2-2. 트랜잭션 Isolation Level 구현

DB의 격리 수준에 따라 어떤 시점의 데이터가 보이도록 할지 제어하기 위해 Lock이 사용된다.

### 2-3. 비정상 상태 방지

Dirty Read, Lost Update, Phantom Read 같은 트랜잭션 부작용을 방지하기 위해 필수적이다.

---

# 3. Lock의 종류

DB마다 용어 차이는 있지만, 대부분 공유락과 배타락 2개를 기반으로 한다.

## 3-1. Shared Lock (공유락, S)

### 1) 정의

공유락은 **읽기 작업(Read)** 을 안전하게 수행하기 위해 사용되는 잠금이다. 여러 트랜잭션이 동시에 

동일한 데이터를 읽는 것은 문제되지 않기 때문에, **여러 개의 공유락은 서로 공존**할 수 있음.

공유락은 나는 이 데이터를 읽고 있으니, 다른 사람도 읽는 건 괜찮지만 

**누구도 수정해서는 안 된다**는 의미를 가짐.

### 2) 특징

- 여러 트랜잭션이 동시에 공유락을 획득 가능
- 하지만 공유락이 걸린 데이터는 **수정(`UPDATE`/`DELETE`) 불가**
- **`SELECT ... FOR SHARE  `** 같은 쿼리에서 명시적으로 사용
- Repeatable Read 이상에서는 내부적으로 읽기 락이 필요해지는 경우가 있음

### 3) 왜 필요한가?

DB는 읽는 동안 데이터가 갑자기 수정되면 일관성이 깨지기 때문에, 읽기 작업도 **정합성 유지**라는 관점에서

보호가 필요. 공유락은 이 역할을 담당.

## 3-2. Exclusive Lock (배타락, X)

### 1) 정의

배타락은 **쓰기 작업(`UPDATE`, `DELETE`, `INSERT`)** 을 수행하기 위해 사용되는 잠금이다.

배타락은 오직 **하나의 트랜잭션만 보유**할 수 있으며, 락이 유지되는 동안 다른 어떤 락(S/X)도 

접근할 수 없음. 배타락은 나는 이 데이터를 수정 중이니 **그 누구도 읽거나 쓸 수 없다**는 의미를 가짐.

### 2) 특징

- 하나의 트랜잭션만 획득 가능
- 공유락도, 배타락도 모두 차단
- **`UPDATE`**, **`DELETE`** 를 실행하면 자동으로 배타락이 걸림
- 충돌이 가장 많이 발생하는 락
- 블로킹, 데드락의 주원인

### 3) 배타락과 읽기 작업의 예외 (MVCC)

이론적으로 배타락은 타 트랜잭션의 **읽기**도 차단해야 한다.
하지만 **MySQL(InnoDB) 등 대부분의 현대 DB**는 **MVCC(다중 버전 동시성 제어)** 기술을 사용하여 이 문제를 해결한다.

- **일반 `SELECT`:** 배타락이 걸려 있어도 **대기하지 않고 읽기 가능**.
    - DB가 락이 걸리기 전의 **과거 데이터(Undo Log의 스냅샷)** 를 보여주기 때문 (Non-locking Consistent Read).
- **`SELECT ... FOR SHARE`:** 명시적으로 락을 거는 읽기 시도는 **대기(Blocking)** 발생.

## 3-3. 공유락 vs 배타락

| 항목 | 공유락 (S-Lock) | 배타락 (X-Lock) |
| --- | --- | --- |
| 목적 | 읽기 보호 | 쓰기 보호 |
| 동시에 획득 가능? | 가능 | 불가능 |
| 다른 읽기 허용? | 허용 | 허용 안 됨 |
| 다른 쓰기 허용? | 불가능 | 불가능 |
| 충돌 가능성 | 낮음 | 매우 높음 |
| 사용 상황 | SELECT (일부), LOCK IN SHARE MODE | UPDATE, DELETE, INSERT |

## 3-4. Lock의 단위

락이 적용되는 범위(Granularity)로 구분. 대부분의 DB는 크게 3개의 단위로 구분.

### 3-4-1. Row Lock (행 단위 락)

- **정의**
    - 테이블 내의 특정 하나의 행(Row)에만 잠금을 거는 방식.
- **특징**
    - 동시성(Concurrency)이 가장 뛰어난 락
    - 실제 UPDATE/DELETE 시 가장 많이 사용되는 기본 락
    - 여러 트랜잭션이 동일 테이블을 사용하더라도 **행이 다르면 서로 간섭하지 않음**
- **장점**
    - 락 범위가 가장 좁기 때문에 동시 처리량이 높음
    - 충돌 발생 가능성이 낮아 블로킹/데드락 위험이 상대적으로 적음
- **단점**
    - 락 관리 비용이 높다(행이 많아지면 락도 많아짐)

### 3-4-2. Page Lock (페이지 단위 락)

- **정의**
    - DB 내부의 저장 단위인 "페이지(블록)" 단위로 락을 거는 방식.
        
        한 페이지는 여러 Row를 포함한다.
        
- **특징**
    - Row Lock보다 범위가 넓고, Table Lock보다 좁은 중간 단계
    - 어떤 스토리지 엔진은 내부적으로 Page Lock을 사용하거나,
        
        혹은 Row Lock이 너무 많아지면 Page Lock으로 승격(lock escalation)하기도 함
        
- **장점**
    - Row Lock보다 관리 비용이 낮고, 속도가 더 빠른 경우도 있음
- **단점**
    - 충돌 가능성이 Row Lock보다 높음
    - 같은 페이지 안의 다른 Row들을 제한할 수 있어 예상치 못한 Block 발생 가능

### 3-4-3. Table Lock (테이블 단위 락)

- 정의
    - 테이블 전체를 잠그는 락.
- 특징
    - 해당 테이블의 모든 읽기/쓰기 작업을 차단하거나 제한
    - DDL(ALTER, DROP), 인덱스 생성, 테이블 스캔 기반 UPDATE 등에서 발생
- 장점
    - 락 충돌 판단이 단순하여 내부 처리 성능이 안정적
    - 대량 배치나 구조 변경 시 유용
- 단점
    - 동시성 최악
    - 서비스 중 잘못 걸리면 전체 요청이 대기 상태로 밀려 장애 발생 가능

### 3-4-4. 요약

| 락 단위 | 범위 | 동시성 | 충돌 가능성 | 사용되는 상황 |
| --- | --- | --- | --- | --- |
| **Row Lock** | 단일 행 | 가장 좋음 | 낮음 | UPDATE/DELETE 기본 |
| **Page Lock** | 여러 행이 포함된 페이지 | 중간 | 중간 | 특정 DB 엔진의 내부 관리 |
| **Table Lock** | 전체 테이블 | 가장 낮음 | 가장 높음 | DDL, 대량 처리, 인덱스 없는 조건 |

---

# 4. 블로킹(Blocking)

## 4-1. 정의

블로킹은 한 트랜잭션이 다른 트랜잭션이 보유하고 있는 Lock이 풀리기를 기다리며

대기 상태로 멈추는 현상이다.

> 이미 누군가 이 데이터에 대한 권한을 가지고 있으니까,
> 
> 
> 나는 그 사람의 작업이 끝날 때까지 기다리겠다.
> 

## 4-2. 언제 발생하는가?

- A 트랜잭션이 특정 Row에 **배타락(X-Lock)** 을 걸고 **`UPDATE`** 중인데
- B 트랜잭션이 같은 Row를 읽거나 수정하려 하면
- B는 A가 Commit 또는 Rollback 할 때까지 **대기 상태**가 된다

가장 기본적인 형태이다.

## 4-3. 예시

### 트랜잭션 A

```sql
START TRANSACTION;
UPDATE account SET balance = balance - 100 WHERE id = 1;
-- Commit을 하지 않고 오래 작업
```

### 트랜잭션 B

```sql
UPDATE account SET balance = balance + 50 WHERE id = 1;
```

### 결과

트랜잭션 B는 A가 락을 가지고 있으므로 **대기(blocking)** 상태로 들어간다.

다른 **`SELECT`** / **`UPDATE`** 요청도 영향을 받아 서비스 응답이 지연되기 시작한다.

이게 실제 운영환경에서 **장애의 시작점**이 된다.

## 4-4. 블로킹이 위험한 이유

- 대기 중인 커넥션이 쌓여서 **DB Connection Pool**이 고갈됨
- 다른 서비스 요청까지 영향을 받아 전체 시스템 지연 또는 다운
- 락 대기 시간이 길어지면 **Lock Timeout**이 발생
- 대량 처리/스크립트 작업이 잘못되면 실시간 요청까지 줄 세움

---

# 5. 데드락(Deadlock)

## 5-1. 정의

데드락은 **두 개 이상의 트랜잭션이 서로 상대방이 보유한 Lock을 기다리며 영원히 대기하는 상태**

> A는 B가 가진 락을 기다리고 있고,
> 
> 
> B는 A가 가진 락을 기다리기 때문에
> 
> 둘 다 끝날 수 없다.
> 

DB 입장에서는 두 작업 모두 진행할 수 없으므로 **둘 중 하나를 강제 종료**시켜 해결한다.

---

## 5-2. 예시

### 트랜잭션 A

```sql
START TRANSACTION;
UPDATE member SET name = 'A' WHERE id = 1;
-- id=1 Row에 X-Lock 보유
```

### 트랜잭션 B

```sql
START TRANSACTION;
UPDATE member SET name = 'B' WHERE id = 2;
-- id=2 Row에 X-Lock 보유
```

이제 아래 상황이 발생하면?

### 트랜잭션 A

```sql
UPDATE member SET name = 'AA' WHERE id = 2;
-- id=2는 이미 B가 잠금 → A는 대기
```

### 트랜잭션 B

```sql
UPDATE member SET name = 'BB' WHERE id = 1;
-- id=1은 A가 잠금 → B도 대기
```

### 결과

- A는 id=2를 기다리고 있고
- B는 id=1을 기다리고 있음
- 서로 상대가 락을 풀어줘야만 완료 가능
- 하지만 상대는 자신이 기다리는 락 때문에 Commit하지 못함

**→ 두 트랜잭션 모두 무한 대기 → 데드락 발생**

DB는 이를 감지하고 보통 다음과 같은 에러를 발생시킴:

```sql
Deadlock found when trying to get lock; try restarting transaction
```

---

# 용어 정리

| 용어 | 정의 |
| --- | --- |
| **정합성(Consistency)** | 트랜잭션 수행 전후로 데이터가 비즈니스 규칙에 맞게 올바른 상태를 유지하는 성질. Lock은 정합성 보장을 위해 사용된다. |
| **무결성(Integrity)** | 데이터가 정확하고 모순 없이 유지되는 성질. 잘못된 값이 저장되거나 구조가 깨지는 것을 방지한다. |
| **트랜잭션(Transaction)** | 하나의 논리적 작업 단위. 모두 성공할 경우 Commit, 실패하면 Rollback 한다. |
| **Isolation Level(격리 수준)** | 여러 트랜잭션이 동시에 실행될 때 서로의 변경을 어느 수준까지 허용할지 결정하는 DB의 동작 규칙. |
| **비정상 상태(Anomaly)** | 동시성 문제로 인해 발생하는 잘못된 읽기/쓰기 결과. Dirty Read, Lost Update, Phantom Read 등이 포함된다. |
| **Dirty Read** | 다른 트랜잭션이 Commit하지 않은 변경 사항을 읽어버리는 문제. |
| **Lost Update** | 여러 트랜잭션이 동시에 수정 작업을 수행하면서 일부 수정 결과가 덮어써져 “사라지는” 문제. |
| **Phantom Read** | 같은 조건의 범위 조회를 반복했을 때, 중간에 새로운 Row가 추가되어 조회 결과가 달라지는 문제. |
| **Lock(잠금)** | 트랜잭션 간 충돌을 방지하기 위해 특정 데이터에 대해 읽기 또는 쓰기 권한을 점유하는 메커니즘. |
| **Shared Lock (공유락, S-Lock)** | 읽기 작업을 위한 락. 여러 트랜잭션이 동시에 읽기 가능하지만, 쓰기 작업은 차단된다. |
| **Exclusive Lock (배타락, X-Lock)** | 쓰기 작업을 위한 락. 읽기·쓰기 모두 차단하며 하나의 트랜잭션만 획득할 수 있다. |
| **SELECT ... FOR SHARE** | SELECT 시 공유락(S-Lock)을 명시적으로 요청하는 SQL 구문. 읽기는 허용하지만 수정은 차단한다. |
| **MVCC** | 다중 버전 동시성 제어. 락을 사용하지 않고도 읽기 작업을 수행할 수 있도록, 데이터의 여러 버전(Snapshot)을 관리하는 기법. |
| **Undo Log** | 트랜잭션이 데이터를 수정할 때, 변경 전의 데이터를 백업해두는 공간. 롤백이나 MVCC 읽기(과거 데이터 조회) 시 사용된다. |
| **Row Lock** | 특정 Row 단위로 걸리는 락. 동시성 확보에 가장 유리하며 UPDATE/DELETE 기본 동작에서 사용된다. |
| **Page Lock** | DB 내부 저장 단위인 페이지(블록) 단위로 걸리는 락. Row Lock보다 범위가 넓고 Table Lock보다 좁다. |
| **Table Lock** | 테이블 전체에 걸리는 락. DDL 변경, 대량 작업, 인덱스 없는 조건 등에서 발생할 수 있다. |
| **Blocking(블로킹)** | 한 트랜잭션이 다른 트랜잭션의 락이 풀리기를 기다리며 대기 상태에 머무르는 현상. |
| **Deadlock(데드락)** | 두 트랜잭션이 서로의 Lock 해제를 기다리며 영원히 진행하지 못하는 교착 상태. |
| **Commit** | 트랜잭션의 모든 변경 내용을 영구적으로 반영하는 동작. |
| **Rollback** | 트랜잭션에서 수행한 변경을 모두 취소하고 이전 상태로 되돌리는 동작. |
| **Connection Pool 고갈** | 블로킹이 심해져 DB 커넥션이 모두 대기 상태로 전환되면서 새로운 요청을 처리할 수 없게 되는 상태. |

---

# 참고 자료

- MySql 공식 자료 : [https://dev.mysql.com/doc/refman/8.4/en/innodb-locking-transaction-model.html](https://dev.mysql.com/doc/refman/8.4/en/innodb-locking-transaction-model.html?utm_source=chatgpt.com)
- MariaDB 공식 자료: https://mariadb.com/docs/server/server-usage/storage-engines/innodb/innodb-lock-modes
- https://mark-kim.blog/mysql_innodb_lock/
- https://github.com/NKLCWDT/cs/blob/main/Database/Lock.md
- https://ksh-coding.tistory.com/121
