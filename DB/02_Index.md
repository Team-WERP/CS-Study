# 인덱스

### 정의
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

1. key-value 형태의 인덱스 테이블에서 where 조건에 포함된 값을 찾는다.
2. 인덱스 노드에 저장된 PK를 가져온다.<br/>
>**인덱스 노드**: 인덱스 트리를 구성하는 하나의 데이터 저장 단위
3. 가져온 PK로 원본 테이블에서 값을 조회한다.

### 종류
**1. Clustered Index 클러스터드 인덱스** <br/>
<img width="579" height="303" alt="Screenshot 2025-11-27 at 12 59 38 AM" src="https://github.com/user-attachments/assets/2fd349ab-5254-439a-a53c-f221e07c9289" />
-  테이블 당 하나만 존재할 수 있으며, 데이터의 물리적인 순서와 인덱스의 순서가 같기 때문에 빠른 검색이 가능하다.<br/>
- 실제 데이터와 함께 저장되어 불필요한 디스크 공간을 추가적으로 유발하지 않는다.

**2. Non-Clustered Index 논클러스터드 인덱스**
<br/>
<img width="579" height="333" alt="Screenshot 2025-11-27 at 12 59 50 AM" src="https://github.com/user-attachments/assets/a8016128-6f4f-48cf-b28c-ae8818084b39" />
- 데이터가 저장된 테이블과 별도의 공간에 위치한다.
- 테이블의 데이터와 별도의 순서로 유지된다.
- 데이터의 위치를 가리키는 포인터를 사용하여 데이터를 찾는다.
- 하나의 테이블에 여러 개의 논클러스터드 인덱스를 생성 가능하다.
- PK외에 다른 유니크 인덱스가 존재하는 경우 논클러스터드 인덱스로 구성이 된다.

**2-1. Unique Index**<Br/>

값이 중복될 수 없는 인덱스.
- 한 컬럼 또는 복합 컬럼 조합이 모두 유일해야 한다.
- MySQL은 데이터를 Insert할 때 중복 여부를 먼저 확인
→ 무결성 보장
- 유니크 인덱스는 NULL 허용 (단, NULL 둘 이상 가능)


**3. Composite Index 복합 인덱스**<br/>

여러 개의 컬럼을 하나의 인덱스로 묶어 만든 인덱스.
- where절에서 and 조건으로 자주 통합되어 사용되면서 각각의 분포도보다 두 개 이상의 컬럼이 통합될 때 분포도가 좋아지는 컬럼들에 사용하기 좋음.
- 다른테이블과 조인의 연결고리로 자주 사용되는 컬럼들에 사용하기 좋음.
- 인덱스 생성 시 정의한 컬럼 순서가 매우 중요
    - (A, B, C) 인덱스라면 다음 조건에서 인덱스 사용됨:<br/>
        A<br/>
        A, B<br/>
        A, B, C

        하지만 B, C만 사용하면 인덱스 미사용


### 특징
- SELECT, UPDATE, DELETE의 성능이 향상된다.
    - 인덱스를 사용하지 않은 컬럼 조회시, Full Scan을 수행해야 하기 때문이다.
    - 인덱스를 사용하면 Range Scan을 함으로 검색에 대한 처리가 빨리 이루어진다.
- Primary Key, Unique Key가 부여된 열에는 불필요하다.(자동으로 인덱스가 설정되어 있기 때문에)
- 한개의 테이블에 복수의 인덱스를 작성한 경우 오히려 성능이 떨어질 수 있다.

### 설계
인덱스 선택 및 순서에 따라 인덱스를 이용한 스캔을 하므로 인덱스를 설계할 때부터 순서를 유의해서 만들어야한다.

1. 조건절에 항상 또는 자주 사용되는 컬럼 선택
2. '=' 조건으로 자주 조회되는 컬럼들을 앞쪽 순서에 위치
3. 분포도가 좋은 컬럼 선정(15%이내)


 #### **분포도**
 특정 컬럼의 값들이 데이터 전체에 어떻게 퍼져 있는지를 나타내는 지표.<br/>

 인덱스가 쓸모 있으려면 쿼리와 매치되는 행의 비율이 작아야 한다(ex. 회원id, 주민번호).<br/>하나의 값으로 조회했을 때 전체 테이블 중 작은 비율만 걸려야 인덱스가 효율적이고 한 값이 전체의 높은 비율을 차지하면 그 컬럼은 조회 시 많은 행을 걸러내므로 인덱스 이득이 적고 오히려 풀스캔이 더 낫다.<br/>
<br/>

### 인덱스가 필요 없는 경우
1. 데이터가 적은 경우
2. 조회보다 삽입, 수정, 삭제 처리가 많은 테이블의 경우
3. 분포도가 15% 이상인 경우

### 스캔 방식
1. **Full Scan(풀 스캔)**<br/>
테이블에 포함된 레코드를 처음부터 끝까지 읽어들이는 것.

2. **Range Scan(레인지 스캔) - 인덱스가 사용하는 방식**<br/>
테이블의 일부(특정) 레코드에만 엑세스해서 읽어들이는 것<br/>

### 자료구조 <br/>
innoDB 인덱스는 **B+Tree 자료구조**를 사용한다.
B+Tree는 B-Tree의 변형으로, 리프 노드에만 데이터를 저장하고, 연결 리스트로 구성되어 있기에 범위 검색에 더 효율적인 자료구조이다.
> https://munak.tistory.com/182
<br/>

### 인덱스 생성 및 조회

```
-- 인덱스 생성
CREATE INDEX 인덱스이름
ON 테이블이름 (필드이름1, 필드이름2, ...);

CREATE INDEX item_index
ON item(id);

-- 인덱스 정보 조회
SHOW INDEX FROM 테이블이름;
```

<br/>

### 인덱스가 적용되지 않는 경우
- 조회되는 데이터가 전체 데아터의 20~30% 이상일 경우
- NOT/IN으로 비교된 경우(NOT/IN 자체는 아님, NOT/IN과 함꼐 사용된 비교 연산자로 나온 데이터의 비율이 높은 경우에 인덱스가 적용되지 않는다.)
- 인덱스가 적용된 컬럼을 수정할 경우
    ```
    SELECT * FROM member WHERE age * 10 = 9 // Index 적용 X
    SELECT * FROM member WHERE age = 9 * 10 // Index 적용 O
    ```
---
**참조 링크**<br/>
https://mangkyu.tistory.com/96<br/>
https://smartpro.tistory.com/61<br/>
https://hstory0208.tistory.com/entry/DB-Index%EC%83%89%EC%9D%B8%EB%9E%80-%ED%8A%B9%EC%A7%95-%EC%A2%85%EB%A5%98-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90-%EB%93%B1%EC%9D%84-%EC%89%BD%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90<br/>
