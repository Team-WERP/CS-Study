# 객체 지향
 ### Object-Oriented Programming, OOP
현실 세계의 모든 사건(event)는 객체와 객체의 상호작용에 의해 일어난다는 세계관을 프로그램을 만들 때 이용하여 새로운 세계를 창조하는 방법론이다.

**장점**
1. 코드 재사용이 용이하다.
2. 유지보수가 쉽다.

**단점**
1. 처리속도가 상대적으로 느리다.
2. 설계시 많은 시간과 노력이 필요하다.

--- 
## 상속
> 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해주는 것.

**is-a / has-a**<br/>
상속관계(is-a): ~은 ~이다. 
포함관계(has-a): ~은 ~을 가지고 있다. 

**extends** 키워드 사용<br/>
부모 클래스는 자식 클래스에 접근할 수 없다. 
자바는 다중상속을 지원하지 않는다.

**다이아몬드 문제** <br/>
Child 클래스가 Mother, Father 클래스를 상속하는데, 만약 Mother과 Father에 같은 메서드가 있으면서 가문()을 서로 다르게 오버라이딩 했다면 
JVM에서 어떤 Mother / Father에서 어떤 가문()을 Child가 상속받아야하는지 모르기 때문에 child.가문()을 할 시 에는 컴파일 에러가 발생한다.

이와 같이 `여러 부모 클래스가 같은 메서드를 정의했을 때, 자식 클래스가 어느 것을 상속해야 하는지 모호해져 발생하는 상속 충돌 문제`를 다이아몬드 문제라고한다.

### 상속과 메모리 구조
<img width="343" height="168" alt="Screenshot 2025-11-21 at 12 24 24 PM" src="https://github.com/user-attachments/assets/4827777f-943f-4622-8a5e-3acff30e1ff7" /><br/>
ElectricCar electricCar = new ElectricCar();을 하면 ElectricCar뿐만 아니라 상속 관계에 있는 Car까지 포함해서 인스턴스를 생성한다. <br/>
외부에서 볼 때는 하나의 인스턴스를 생성하는 것 같지만 내부에는 부모와 자식이 모두 생성되고 공간도 구분된다. 
<br/>
1. electricCar.charge()를 호출하면 참조값을 확인하여 x001.charge() 호출한다.<br/>
2. 상속 관계의 경우 x001 내부에 부모와 자식이 모두 존재하기 때문에 호출하는 변수의 타입(클래스)을 기준으로 선택한다. <br/>
3. electricCar 변수의 타입이 ElectricCar이므로 내부에 같은 타입인 ElectricCar을 통해서 charge()를 호출한다.<br/>
4. 변수 타입에 없다면 부모 타입에서 메서드를 찾고, 상위 부모 타입에서도 존재하지 않는다면 컴파일 에러가 발생한다.


### super
부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없다. 하지만 `super` 키워드를 사용하면 부모를 참조할 수 있다.

**사용 경우**
1. 부모 클래스의 변수(필드)에 접근할 때
2. 부모 클래스의 메서드 호출
3. 부모 생성자 호출

super()는 생성자 코드 안에서 사용될 때, 다른 코드에 앞서 첫줄에 사용되어야한다.<br/>
자식 클래스의 모든 생성자는 부모 클래스의 생성자를 포함하고 있어야한다. <br/>
만약 자식 클래스의 생성자에 부모 클래스의 생성자가 지정되어 있지 않다면, 컴파일러가 자동으로 부모 클래스의 기본 생성자를 호출한다.

## 캡슐화
객체의 내부 구조 및 데이터를 캡슐처럼 감싸 외부에서 직접 볼 수 없게 은닉하여 보호하는 것.<br/>
클래수와 멤버변수, 멤버함수는 외부에서 접근 가능한 범위를 지정할 수 있는 접근제어자와 함께 사용된다.

| 접근 제어자     | 접근 가능 범위 |
|----------------|------------------------------------------------------------|
| `public`       | 모든 클래스에서 접근 가능 (패키지와 무관) |
| `private`      | **같은 클래스 내부**에서만 접근 가능 |
| `protected`    | **같은 패키지의 모든 클래스**, 그리고 **다른 패키지의 자식 클래스**에서 접근 가능 |
| (default)      | 접근 지정자 생략 시 적용. **같은 패키지 내의 클래스**에서만 접근 가능 |

**공개범위**<br/>
*public > protected > default > private*

```
// 예시
public class Person {
	
	private int age;
	
	
	public int getAge() {
		return age;
	}
	
	public void setAge(int age) {
		if (age >= 0) {
			this.age = age;			
		}
	}
}
```
외부에서 Person의 private인 age변수에 접근하기 위해서는 **setter**와 **getter**를 이용해서 접근 할 수 있다.

## 추상화
> 객체에서 공통된 속성과 행위를 추출하여 공통적인 특성을 파악하고 불필요한 특성을 제거하는 과정.

**추상 클래스**<br/>
부모 클래스는 제공하지만 실제로 생성되면 안되는 클래스
- 인스턴스를 생성할 수 없다.(new 클래스명() 불가)
- 상속 목적으로 사용되고 부모 클래스 역할을 한다.
- **abstract** 키워드 사용

**추상 메서드**<br/>
자식 클래스가 반드시 오버라이딩 해야하는 메서드
- **abstract** 키워드 사용
- 메서드 body 존재하지 않음(선언만 해준다)

추상 메서드를 1개라도 가지는 클래스는 추상 클래스로 선언해야한다.

**예제**<br/>
```
public abstract class AbstractAnimal {
	public abstract void sound();
}

public class Dog extends AbstractAnimal {
	@Override
	public void sound() {
		System.out.println("월월");
	}
}

public static void main(String[] args) {
	// 추상 클래스의 인스턴스 생성 불가!
	// AbstractAnimal abstractAnimal = new AbstractAnimal();	
}
```

### 인터페이스
클래스 내의 모든 메서드가 추상 메서드인 추상 클래스
```
public interface InterfaceAnimal {
	public abstract void sound();
	public abstract void move();
}
```
인터페이스를 구현하는 클래스는 반드시 모든 메서드를 오버라이딩 해야한다.<br/>

**특징**<br/>
- 순수 추상 클래스와 동일
- 인터페이스 내 모든 메서드는 **public abstract**가 자동 추가됨
- 모든 멤버 변수는 **public static final**
- 다중 구현 지원 (상속과 다중 구현을 동시에 할 수도 있다.)
<br/>

**추상클래스와 인터페이스 비교** <br/>

| 구분 | 추상 클래스 | 인터페이스 |
| --- | --- | --- |
| 상속 가능 범위 | 단일 상속 | 다중 상속 |
| 키워드 | extends 사용 | implements 사용 |
| 추상 메소드 개수 | abstract 메소드 0개 이상 | 모든 메소드는 abstract |
| abstract 키워드 명시 | 명시적 사용 | 묵시적으로 abstract |


## 다형성
> 하나의 인스턴스가 여러 가지 타입을 가질 수 있는 것을 의미한다.
 하나의 타입으로 여러 타입의 인스턴스를 처리할 수 있기도 하고, 하나의 메소드 호출로 객체별로 각기 다른 방법으로 동작하게 할 수 도 있다.

### 다형적 참조
부모 타입의 변수가 자식 인스턴스 참조하는 것.
부모는 자식 타입을 담을 수 있다. 손자가 있다면 손자도 그 하위 타입도 참조할 수 있다. 하지만 반대로 자식 타입은 부모 타입을 담을 수 없다.

**동적 바인딩**<br/>
 런타임 시 실제 해당 인스턴스가 메소드(오버라이딩 한 메소드)로 바인딩이 바뀌어 동작하는 것을 의미한다.


**다운캐스팅**<br/>
Parent poly 변수가 있고, parentMethod()를 가지고 있다면, (Child) poly.childMethod(())
하지만 자식의 메서드는 호출할 수 없다.

**업캐스팅**<br/>
Chile child = new Child();
Parent parent1 = (Parent) child; // 업캐스팅은 (Parent) 생략 가능(생략하는 것을 권장)

**instanceof**<br/>
참조 변수의 형 변환이 가능한지 여부를 boolean 타입으로 확인할 수 있는 자바의 문법 요소.
업캐스팅 또는 다운 캐스팅이 가능한지 검사하는 것.
 `참조변수 instanceof 타입`

```
class Animal{}
class Dog extends Animal{}

public class InstanceOfTest{
    public static void main(String[] args) {
        Animal animal = new Animal();
        Animal cat = new Cat();
     System.out.println(cat instanceof Object); // true
        System.out.println(cat instanceof Animal); // true
        System.out.println(cat instanceof Dog); // false
        System.out.println(cat instanceof Cat); // true
    }
}
```

**오버로딩 / 오버라이딩**<br/>
메서드를 확장하거나 재정의 하는 오버로딩 / 오버라이딩도 메서드가 다형성 해지기 때문에 자바의 다형성 특징 중 하나에 속한다.

### 다형성 활용
```
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();  // 다형성
        Animal a2 = new Cat();  // 다형성

        a1.sound(); // "멍멍!"
        a2.sound(); // "야옹!"
    }
}
```

참고자료
https://ittrue.tistory.com/132
https://inpa.tistory.com/entry/OOP-JAVA%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1Polymorphism-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4

