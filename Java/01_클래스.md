# 클래스 (Class)


## 1. 클래스 개념

### 1.1. 클래스란 무엇인가?

클래스(Class)는 **객체를 만들기 위한 설계도**로, 객체의 속성과 행동을 정의한다.<br>
이때 속성은 필드로, 행동은 메서드로 표현된다.

예를 들어, 자전거라는 객체를 표현하기 위해 다음과 같은 클래스를 정의할 수 있다.

```java
class Bicycle {
    int speed = 0;
    int gear = 1;

    void changeGear(int newValue) {
        gear = newValue;
    }

    void speedUp(int increment) {
        speed = speed + increment;   
    }

    void applyBrakes(int decrement) {
        speed = speed - decrement;
    }

    void printStates() {
        System.out.println(" speed:" + speed + " gear:" + gear);
    }
}
```

<br>

### 1.2. 클래스를 사용하는 이유

기본적으로 자바는 객체지향 언어이기 때문에 프로그램을 객체 중심으로 설계하며, 이때 객체를 만들기 위한 설계도로 클래스가 필요하다. 또한 클래스를 사용하지 않으면 다음과 같은 문제가 발생할 수 있다.

**1. 관련 데이터를 하나로 묶기 어렵다**

여러 변수가 서로 연관되어 있어도 각각 따로 선언해야 하므로 관리가 복잡해지고,
데이터 구조가 흐트러져 프로그램의 응집도가 떨어진다.

**2. 메서드의 매개변수가 불필요하게 많아진다**

관련된 값들을 하나씩 전달해야 하므로 메서드 시그니처가 길어지고 가독성이 떨어진다.
이는 리팩토링 시점의 신호가 되는 “코드 스멜(Code smell)”로 간주된다.

**3. 여러 값을 함께 반환하기 어렵다**

자바 메서드는 하나의 값만 반환할 수 있으므로, 여러 값을 다뤄야 하는 상황에서 제약이 생긴다.
클래스를 활용하면 여러 속성을 하나의 객체로 묶어 자연스럽게 반환할 수 있다.

<br>


### 1.3. 클래스 vs 인스턴스 vs 객체

클래스(Class), 객체(Object), 인스턴스(Instance)는 객체지향에서 매우 중요하지만 혼동되기 쉽다.
Oracle 공식 문서에서는 다음과 같이 설명한다.

>  In object-oriented terms, we say that your bicycle is an **instance** of the **class** of **objects** known as bicycles. 

위 문장을 보면 세 개념의 관계가 잘 드러난다.

**객체(Object)**

- 만들고자 하는 대상 그 자체
- 현실 세계의 “자전거”처럼 독립된 실체를 의미
- 프로그램에서는 메모리에 생성된 모든 것을 포괄적으로 ‘객체’라고 부름
- ex. `자전거(bicycle)라는 대상`

**클래스(Class)**

- 객체를 만들기 위한 설계도(blueprint)
- 어떤 속성과 기능을 가질지 정의하는 틀
- 자전거가 어떻게 생겼고 어떻게 동작하는지를 설명한 설계도와 같음
- ex. `자전거의 설계도 (speed, gear, brake 등 정의)`

**인스턴스(Instance)**

- 클래스(설계도)를 바탕으로 실제로 만들어진 객체
- ‘클래스의 객체’라는 관계를 강조할 때 쓰는 말
- ex. `설계도를 바탕으로 공장에서 실제로 만들어진 자전거 한 대`

<br>

➡️ 이런 차이가 있지만 실제로는 객체와 인스턴스는 많이 혼용하거나 객체를 주로 사용하고, 관계를 조금 더 강조할 때에 인스턴스를 사용하는 듯 하다.


<br>

## 2. 클래스 구성요소

<details>
<summary>Oracle 공식 문서 </summary>

<br>

클래스 본문(class body)은 멤버들을 선언한다(필드, 메서드, 중첩 클래스, 인터페이스), 그리고 인스턴스 및 static 초기화 블록, 그리고 생성자를 선언한다(§8.1.6). 멤버(§8.2)의 유효 범위(scope, §6.3)는 해당 멤버가 속한 클래스 선언의 전체 본문이다. 필드, 메서드, 멤버 클래스, 멤버 인터페이스, 생성자 선언에는 접근 제어자(public, protected, private)를 포함할 수 있다(§6.6). 클래스의 멤버는 선언된 멤버뿐 아니라 상속된 멤버도 포함한다(§8.2).

> The body of a class declares members (fields and methods and nested classes and interfaces), instance and static initializers, and constructors (§8.1.6). The scope (§6.3) of a member (§8.2) is the entire body of the declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers (§6.6) public, protected, or private. The members of a class include both declared and inherited members (§8.2).

</details>

<br>

클래스의 body에는 다음 구성 요소를 선언할 수 있다.

- 필드(Field) : 객체의 속성을 저장하는 변수
- 메서드(Method) : 객체의 행동(기능)을 정의하는 코드 블록
- 생성자(Constructor) : 객체 생성 시 호출되는 초기화 메서드
- 중첩 클래스(Nested Class) : 클래스 내부에 선언된 클래스
- 중첩 인터페이스(Nested Interface) : 클래스 내부에 선언된 인터페이스
- 초기화 블록(Initializer) : 인스턴스 또는 static 초기화 코드

<br>

이 중 기본 구성요소는 필드, 메서드, 생성자로 3가지 이다.

### 2.1. 필드 (Field)

필드는 객체가 가지는 상태(state) 를 저장하는 변수이다.
필드는 클래스 내부에 선언되며 객체가 생성될 때 Heap 영역에 함께 생성된다.

```java
class Student {
    String name;
    int age;
}
```

### 2.2. 메서드 (Method)

메서드는 객체가 수행할 행동(behavior)을 정의하며, 필드를 읽거나 수정하는 기능을 제공한다.

```java
class Student {
    void study() {
        System.out.println("공부 중...");
    }
}
```

메서드는 반환 타입, 메서드 이름, 매개변수 리스트, 메서드 body로 구성된다.

### 2.3. 생성자 (Constructor)

생성자는 객체 생성 시 자동으로 호출되는 메서드이며, 객체의 초기 상태를 설정한다.
클래스 이름과 동일하며 반환 타입이 없다.

```java
class Student {
    String name;

    Student(String name) {
        this.name = name;
    }
}
```

생성자를 하나도 정의하지 않으면, 컴파일러가 자동으로 기본 생성자(default constructor) 를 만들어준다.

<br>

아래 요소들은 클래스 구성요소지만, 필드/메서드/생성자만큼 필수는 아니다.

### 2.4. 초기화 블록 (Initializer Block)

인스턴스 생성 시 실행되는 코드 블록이며, 잘 사용되진 않지만 복잡한 초기화가 필요할 때 특별히 사용한다.

```java
{
    // 인스턴스 초기화 블록
}

static {
    // static 초기화 블록
}
```

### 2.5. 내부 클래스 (Nested / Inner Class)

클래스 내부에 선언된 클래스이다. 즉, “클래스 안에 또 하나의 클래스를 정의”하는 구조이다.
캡슐화 강화, GUI, 이벤트 처리 등에 주로 사용된다.

```java
class Outer {
    class Inner {
        void hello() {
            System.out.println("Hello from Inner!");
        }
    }
}
```

<br><br>

## 3. 객체 생성 과정

자바에서 객체(Object) 또는 인스턴스(Instance)는 다음 과정을 통해 생성되고 사용된다.

### 3.1. new로 인스턴스 생성

객체를 생성하기 위해 자바에서는 new 키워드를 사용한다.

```java
Student s = new Student();
```

이 한 줄이 실행될 때 내부적으로는 다음 작업이 이루어진다.

1. Student 클래스 정보를 기반으로 Heap 영역에 새로운 객체(인스턴스) 공간이 생성됨
2. 생성자 Student()가 실행되어 필드 초기화
3. 생성된 객체의 주소값(reference) 이 반환됨
4. 참조 변수 s가 Stack 영역에 만들어지고 해당 주소값을 저장함

new → Heap에 객체 생성, 참조 변수는 Stack에 저장

![alt text](image.png)

### 3.2. 점(.) 연산자로 필드/메서드 접근

객체에 접근할 때는 .(dot) 연산자를 사용한다.

```java
Student s = new Student();
s.name = "민지";   // 필드 접근
s.study();        // 메서드 호출
```

- `s.name` → Student 객체의 name 필드에 접근
- `s.study()` → Student 객체의 study() 메서드 호출

이때 참조변수(s)는 객체 자체가 아닌 Heap에 있는 객체의 주소를 들고 있는 Stack에 있는 변수이다.


### 3.3. 필드(변수)의 종류 3가지

자바의 필드(변수)는 3가지로 구분할 수 있다.

```java
class Student {
    String name;   // 1. 인스턴스 변수
    static int count;  // 2. 클래스 변수

    void study() {
    int time = 3;   // 3. 지역 변수
    }
}
```

**1.인스턴스 변수 (Instance Variable)**

- static 없이 선언된 필드
- 객체(인스턴스)가 생성될 때마다 Heap에 별도로 생성
- 각 객체마다 독립적인 값을 가짐

**2. 클래스 변수 (Class Variable)**

- static 이 붙은 변수
- 클래스 로딩 시 단 한 번 메모리에 생성
- 모든 인스턴스가 공유함

**3.지역 변수 (Local Variable)**

- 메서드 내부에서 선언되는 변수
- Stack 영역에서만 존재, 메서드가 끝나면 사라짐
- 초기화를 하지 않으면 사용 불가

<br>

### 3.4. 메서드 종류 2가지

메서드도 필드와 비슷하게 static의 유무에 따라 2가지로 구분할 수 있다.

```java
class Student {
    static void printCount() { }   // 1. 클래스 메서드
    void study() { }               // 2. 인스턴스 메서드
}
```

**1. 클래스 메서드**

- static 키워드 사용
- 인스턴스 없이 사용 가능
- 인스턴스 변수 접근 불가

**2. 인스턴스 메서드**

- non-static
- 반드시 객체 생성 후 사용
- 인스턴스 변수 접근 가능

<br>

### 3.4. 생성자에서의 this 사용

this 키워드는 다음 두 가지 목적으로 사용된다.

**1. 자신의 인스턴스를 가리키는 키워드**

```java
class Car {
    String name;

    Car(String name) {
        this.name = name;   // 필드 name = 매개변수 name
    }
}
```

**2. 다른 생성자를 호출할 때 (this())**

클래스 내부에서 생성자 간 호출이 가능하다.

```java
class Car {
    String name;
    int year;

    Car() {
        this("noname", 0);  // 다른 생성자 호출
    }

    Car(String name, int year) {
        this.name = name;
        this.year = year;
    }
}
```

## 참고 자료

- [Oracle Java Documentation - What is a Clss?](https://docs.oracle.com/javase/tutorial/java/concepts/class.html)
- [Oracle Java Language Specification - Chapter 8. Classes](https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html)