# 자바 프로그램 실행 과정

자바 프로그램은 다음 5단계를 거쳐 실행

1. **소스 코드 작성(.java)**
2. **컴파일(Compiler: javac) → 바이트코드(.class)**
3. **클래스 로딩(Class Loader)**
4. **바이트코드 검증(Bytecode Verifier)**
5. **실행(Execution Engine: 인터프리터 + JIT 컴파일러)**
    

<img width="1281" height="755" alt="Image" src="https://github.com/user-attachments/assets/87ecf3c3-bfb6-41e4-bea1-b07be7690548" />

    

---

## 1. 소스 코드 작성 (Hello.java)

- 개발자가 `.java` 파일에 자바 문법으로 코드를 작성한다.
    
    ```java
    publi class Hello {
    	public static void main(String[] args){
    				System.out.println("Hello, World");
    		}
    }
    ```
    
- 이 코드는 사람이 이해하기 쉬운 **고급 언어(High-level Language)** 형태.

 **– 왜 기계어로 바로 작성하지 않을까?**

사람이 이해하기 쉬운 문법 구조를 제공함으로써 생산성을 높이기 위함이다.

기계어는 CPU마다 다르기 때문에, 기계어로 바로 작성하면 OS 종속 문제가 발생한다.

---

## 2. 컴파일 (javac → .class 생성)

- `javac` 컴파일러가 `.java` 코드를 읽고 **바이트코드(.class)** 로 변환
- 바이트코드는 특정 CPU나 OS에 종속되지 않은 **중간 언어(Intermediate Language)** 다.

**– 왜 바이트코드를 사용하는가? (핵심)**

- 각 운영체제가 사용하는 기계어는 모두 다르다.
- 하지만 **바이트코드 → JVM → 기계어** 구조를 사용하면
    
    **어떤 OS에서든 실행 가능한 공통 실행 환경(JVM)을 제공**할 수 있다.
    
- 이것이 자바의 유명한 문구 **WORA(Write Once, Run Anywhere)** 를 가능하게 한다.

---

## 3. 클래스 로딩 (Class Loader)

- 실행 시 필요한 `.class` 파일을 JVM 메모리로 불러오는 과정.
- Java는 전체 프로그램을 한 번에 로딩하지 않고,
    
    필요한 클래스만 **동적 로딩(Dynamic Loading)** 한다.
    

 **– 왜 동적 로딩이 필요한가?**

- 모든 클래스를 한 번에 올리면 메모리 낭비가 크다.
- 실제로 사용되는 클래스는 많지 않기 때문에 필요할 때만 로딩하는 구조가 효율적
- 또한 런타임 시점에 외부 라이브러리를 불러오는 유연성을 확보할 수 있다.

---

## 4. 바이트코드 검증 (Bytecode Verifier)

- JVM이 로딩한 `.class` 파일이 안전하고 규칙을 지켰는지 검증
    - 잘못된 명령어 사용 여부
    - 스택 점검
    - 허용되지 않은 메모리 접근 차단

 **– 왜 검사하는가?**

자바는 네트워크를 통해 받은 .class 파일도 실행할 수 있는 언어

→ 즉, 잠재적으로 위험한 코드가 JVM으로 들어올 수 있음.

따라서 JVM은 바이트코드가 **시스템을 망가뜨리지 않고 안전하게 실행될 수 있는지** 확인해야 함

---

## 5. 실행 (Execution Engine: 인터프리터 + JIT)

### 인터프리터(Interpreter)

- 바이트코드를 **한 줄씩 해석하며 실행**
- 빠르게 실행을 시작할 수 있으나 반복되는 작업은 비효율적

### JIT(Just-In-Time) 컴파일러

- 자주 실행되는 코드(HotSpot)를 **기계어로 변환해 캐싱**
- 이후 같은 코드가 실행될 때 훨씬 빠르게 동작

**– 왜 인터프리터 + JIT을 함께 쓸까?**

- 빠른 시작과 오래 실행될수록 최적화되는 성능을 동시에 충족하기 위해서
- 순수 인터프리터 → 시작은 빠르지만 성능은 낮음
- 순수 컴파일 → 초기 시작이 느리지만 최종 성능은 높음
- JVM은 둘을 합쳐 **초기 빠름 + 최적화된 고성능**을 제공

---

## 6. 기계어 실행 (CPU 단계)

- JVM에서 JIT이 생성한 기계어는 OS/CPU에서 실제로 실행
- 최종적으로 하드웨어 수준에서 수행되는 **기계어 명령**으로 변환되어 동작

**– 결국 JVM이 없으면 어떻게 되는가?**

- 운영체제별로 서로 다른 기계어로 다시 컴파일해야 한다.
- 즉, C나 C++처럼 OS별로 빌드를 따로 만들고 배포해야 하는 불편을 겪게 된다.

---

## 7. 용어 정리

| 용어 | 설명 |
| --- | --- |
| **고급 언어 (High-Level Language)** | 사람이 읽기 쉬운 형태의 언어. 예: Java, Python |
| **중간 언어(Intermediate Language)** | 고급 언어와 기계어 사이 단계. 자바의 `.class` 파일 |
| **기계어(Machine Code)** | CPU가 직접 실행 가능한 이진 명령어 |
| **컴파일(Compile)** | 소스 코드를 다른 형태의 코드로 변환하는 과정 |
| **바이트코드(Bytecode)** | JVM이 이해하는 중간 언어. OS/CPU에 독립적 |
| **JVM (Java Virtual Machine)** | 바이트코드를 읽어 실제 기계어로 실행하는 가상 컴퓨터 |
| **동적 로딩(Dynamic Loading)** | 필요한 클래스만 실행 시점에 로딩하는 방식 |
| **Class Loader** | `.class` 파일을 JVM 메모리에 적재하는 컴포넌트 |
| **Bytecode Verifier** | 바이트코드가 안전한지 검사하는 검증기 |
| **인터프리터(Interpreter)** | 바이트코드를 한 줄씩 바로 실행하는 실행 방식 |
| **JIT(Just-In-Time) 컴파일러** | 반복되는 코드를 기계어로 변환해 캐싱하는 컴파일러 |
| **캐싱(Caching)** | 자주 사용되는 데이터를 미리 저장해 두었다가 다음에 필요할 때 빠르게 가져오는 기술. |
| **WORA** | Write Once, Run Anywhere. 한 번 작성해 여러 플랫폼에서 실행 가능 |
